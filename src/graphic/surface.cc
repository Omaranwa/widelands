/*
 * Copyright (C) 2006-2013 by the Widelands Development Team
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

#include "graphic/surface.h"

#include <cassert>
#include <cmath>
#include <cstdlib>

#include <SDL.h>

#include "base/macros.h"
#include "base/point.h"
#include "base/rect.h"
#include "graphic/gl/coordinate_conversion.h"
#include "graphic/gl/utils.h"
#include "graphic/line_draw_mode.h"

namespace {

// This is for drawing the line-joint circles.
// The x and y values are generated by this python code:
// from math import *
// x, y = [], []
// for i in range(kNumTrianglesForCircle):
//   x.append(math.cos(2*pi*float(i)/kNumTrianglesForCircle))
//   y.append(math.sin(2*pi*float(i)/kNumTrianglesForCircle))
constexpr int kNumTrianglesForCircle = 5;
constexpr float kCircleXValues[kNumTrianglesForCircle] = {
   1.f, 0.30901699f, -0.80901699f, -0.80901699f, 0.30901699f,
};
constexpr float kCircleYValues[kNumTrianglesForCircle] = {
   0.f, 0.95105652f, 0.58778525f, -0.58778525f, -0.95105652f,
};

// Adjust 'original' so that only 'src_rect' is actually blitted.
BlitData adjust_for_src(BlitData blit_data, const Rect& src_rect) {
	blit_data.rect.x += src_rect.x;
	blit_data.rect.y += src_rect.y;
	blit_data.rect.w = src_rect.w;
	blit_data.rect.h = src_rect.h;
	return blit_data;
}

// Get the normal of the line between 'start' and 'end'.
template <typename PointType>
FloatPoint calculate_line_normal(const PointType& start, const PointType& end) {
	const float dx = end.x - start.x;
	const float dy = end.y - start.y;
	const float len = std::hypot(dx, dy);
	return FloatPoint(-dy / len, dx / len);
}

float dot(const FloatPoint& p1, const FloatPoint& p2) {
	return p1.x * p2.x + p1.y * p2.y;
}

// Finds the pseudo-normal of a point at the join of two lines. We construct
// this like a miter joint from woodworks. The best explanation I found for
// this algorithm is here
// https://forum.libcinder.org/topic/smooth-thick-lines-using-geometry-shader#23286000001269127
FloatPoint calculate_pseudo_normal(const FloatPoint& p0, const FloatPoint& p1, const FloatPoint& p2) {
	FloatPoint n1 = calculate_line_normal(p0, p1);
	FloatPoint pseudo_normal = n1 + calculate_line_normal(p1, p2);
	float scale = 1. / dot(pseudo_normal, n1);
	// NOCOM(#sirver): this is not working. Instead, switch the joint to something else when the outer lines get too long?
	if (scale > 6.) {
		scale = 1.;
	}
	// log("#sirver scale: %f\n", scale);
	return FloatPoint(pseudo_normal.x * scale, pseudo_normal.y * scale);
}

template <typename PointType>
FloatPoint normalize(const PointType& a) {
	float len = std::hypot(a.x, a.y);
	return FloatPoint(a.x / len, a.y / len);
}

// Tesselates the line made up of 'points' ino triangles and converts them into OpenGL space for a
// renderbuffer of dimensions 'w' and 'h'.
void tesselate_line_strip(int w,
                          int h,
                          const RGBAColor& color,
                          float line_width,
                          std::vector<FloatPoint> points,
                          std::vector<DrawLineProgram::PerVertexData>* vertices) {
	const float r = color.r / 255.;
	const float g = color.g / 255.;
	const float b = color.b / 255.;
	const float a = color.a / 255.;

	const bool closed_loop = points.front() == points.back();
	if (closed_loop) {
		points.pop_back();
	}

	// Figure out the tesselation for the line. The normal for a point is the
	// average of the up to two lines it is part of.
	std::vector<FloatPoint> normals;
	for (size_t i = 0; i < points.size(); ++i) {
		if (i == 0) {
			if (closed_loop) {
				normals.push_back(calculate_pseudo_normal(points.back(), points.front(), points[1]));
			} else {
				normals.push_back(calculate_line_normal(points.front(), points[1]));
			}
		} else if (i == points.size() - 1) {
			if (closed_loop) {
				normals.push_back(
				   calculate_pseudo_normal(points[points.size() - 2], points.back(), points.front()));
			} else {
				normals.push_back(calculate_line_normal(points[points.size() - 2], points.back()));
			}
		} else {
			normals.push_back(calculate_pseudo_normal(points[i - 1], points[i], points[i + 1]));
		}
	}
	if (closed_loop) {
		points.push_back(points.front());
		normals.push_back(normals.front());
	}

	log("#sirver normals.size(): %d,points.size(): %d\n", normals.size(), points.size());
	// Iterate over each line segment, i.e. all points but the last, convert
	// them from pixel space to gl space and draw them.
	for (size_t i = 0; i < points.size() - 1; ++i) {
		const FloatPoint p1 = FloatPoint(points[i].x, points[i].y);
		const FloatPoint p2 = FloatPoint(points[i + 1].x, points[i + 1].y);

		log("#sirver normals.x(): %f, %f\n", normals[i].x, normals[i].y);
		const FloatPoint n1(0.5 * line_width * normals[i].x, 0.5 * line_width * normals[i].y);
		const FloatPoint n2(0.5 * line_width * normals[i+1].x, 0.5 * line_width * normals[i+1].y);

		// Quad points are created in rendering order for OpenGL.
		{
			FloatPoint p = p1 - n1;
			pixel_to_gl_renderbuffer(w, h, &p.x, &p.y);
			vertices->emplace_back(
			   DrawLineProgram::PerVertexData{p.x, p.y, 0.f, r, g, b, a});
		}

		{
			FloatPoint p = p2 - n2;
			pixel_to_gl_renderbuffer(w, h, &p.x, &p.y);
			vertices->emplace_back(
			   DrawLineProgram::PerVertexData{p.x, p.y, 0.f, r, g, b, a});
		}

		{
			FloatPoint p = p1 + n1;
			pixel_to_gl_renderbuffer(w, h, &p.x, &p.y);
			vertices->emplace_back(
			   DrawLineProgram::PerVertexData{p.x, p.y, 0.f, r, g, b, a});
		}

		vertices->push_back(vertices->at(vertices->size() - 2));
		vertices->push_back(vertices->at(vertices->size() - 2));

		{
			FloatPoint p = p2 + n2;
			pixel_to_gl_renderbuffer(w, h, &p.x, &p.y);
			vertices->emplace_back(
			   DrawLineProgram::PerVertexData{p.x, p.y, 0.f, r, g, b, a});
		}
	}

	// Draw a circle around each point, to join the disjunct lines together.
	// Since Widelands only uses very thin lines, a circle with 5 triangles does
	// not look worse than one using 60.
	// for (size_t i = 0; i < points.size(); ++i) {
		// const FloatPoint p1 = FloatPoint(points[i].x, points[i].y);
		// for (int j = 0; j < kNumTrianglesForCircle; ++j) {
			// float x1 = p1.x + 0.5 * line_width * kCircleXValues[j];
			// float x2 = p1.x + 0.5 * line_width * kCircleXValues[(j + 1) % kNumTrianglesForCircle];
			// float y1 = p1.y + 0.5 * line_width * kCircleYValues[j];
			// float y2 = p1.y + 0.5 * line_width * kCircleYValues[(j + 1) % kNumTrianglesForCircle];
			// float x = p1.x;
			// float y = p1.y;
			// pixel_to_gl_renderbuffer(w, h, &x1, &y1);
			// pixel_to_gl_renderbuffer(w, h, &x2, &y2);
			// pixel_to_gl_renderbuffer(w, h, &x, &y);

			// vertices->emplace_back(DrawLineProgram::PerVertexData{x, y, 0.f, r, g, b, a});
			// vertices->emplace_back(DrawLineProgram::PerVertexData{x1, y1, 0.f, r, g, b, a});
			// vertices->emplace_back(DrawLineProgram::PerVertexData{x2, y2, 0.f, r, g, b, a});
		// }
	// }
}

}  // namespace

// NOCOM(#sirver): document: draws a rectangle that has length and width as described. Inner span is w - 2, h -2
void draw_rect(const Rect& rc, const RGBColor& clr, Surface* surface) {
	log("#sirver rc.w: %d,rc.h: %d\n", rc.w, rc.h);
	const FloatPoint top_left = FloatPoint(rc.x + 0.5f, rc.y + 0.5f);
	const FloatPoint top_right = FloatPoint(rc.x + rc.w - 0.5f, rc.y + 0.5f);
	const FloatPoint bottom_right = FloatPoint(rc.x + rc.w - 0.5f, rc.y + rc.h - 0.5f);
	const FloatPoint bottom_left = FloatPoint(rc.x + 0.5f, rc.y + rc.h - 0.5f);

	surface->draw_line_strip(
	   {top_left, top_right, bottom_right, bottom_left, top_left}, clr, 1, LineDrawMode::kSharp);
}

void Surface::fill_rect(const Rect& rc, const RGBAColor& clr) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), rc);
	do_fill_rect(rect, clr, BlendMode::Copy);
}

void Surface::brighten_rect(const Rect& rc, const int32_t factor)
{
	if (!factor) {
		return;
	}

	const BlendMode blend_mode = factor < 0 ? BlendMode::Subtract : BlendMode::UseAlpha;
	const int abs_factor = std::abs(factor);
	const RGBAColor color(abs_factor, abs_factor, abs_factor, 0);
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), rc);
	do_fill_rect(rect, color, blend_mode);
}

void Surface::draw_line_strip(std::vector<FloatPoint> points,
                              const RGBColor& color,
                              float line_width,
                              const LineDrawMode& line_draw_mode) {
	if (points.size() < 2) {
		return;
	}

	std::vector<DrawLineProgram::PerVertexData> vertices;
	// We need for each point the number of triangles for the circle around it 2
	// more triangles for the line to the next point. A triangle has 3 points.
	vertices.reserve(3 * points.size() * (kNumTrianglesForCircle + 2));

	const auto w = width();
	const auto h = height();
	// TODO(sirver): This code relies on depth testing to not draw
	// semi-transparent pixels twice. That also means that kAntialiased will not
	// perform correctly when drawing on offscreen surfaces - which we never do
	// for lines in Widelands.
	tesselate_line_strip(
	   w, h, RGBAColor(color.r, color.g, color.b, 255), line_width, points, &vertices);
	if (line_draw_mode == LineDrawMode::kAntialiased) {
		tesselate_line_strip(w, h, RGBAColor(color.r, color.g, color.b, 100), line_width + 2., points,
		                     &vertices);
	}
	do_draw_line_strip(std::move(vertices));
}

void Surface::blit_monochrome(const Rect& dst_rect,
                              const Image& image,
                              const Rect& src_rect,
                              const RGBAColor& blend) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), dst_rect);
	do_blit_monochrome(rect, adjust_for_src(image.blit_data(), src_rect), blend);
}

void Surface::blit_blended(const Rect& dst_rect,
                           const Image& image,
                           const Image& texture_mask,
                           const Rect& src_rect,
                           const RGBColor& blend) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), dst_rect);
	do_blit_blended(rect, adjust_for_src(image.blit_data(), src_rect),
	                adjust_for_src(texture_mask.blit_data(), src_rect), blend);
}

void Surface::blit(const Rect& dst_rect,
                   const Image& image,
                   const Rect& src_rect,
                   float opacity,
                   BlendMode blend_mode) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), dst_rect);
	do_blit(rect, adjust_for_src(image.blit_data(), src_rect), opacity, blend_mode);
}
